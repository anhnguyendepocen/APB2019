<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Discrete morphology - Tree Inference • apb2019</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><meta property="og:title" content="Discrete morphology - Tree Inference">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../../index.html">apb2019</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/RB_Discrete_Morphology/RB_MCMC_Discrete_Morph.html">Discrete morphology - Tree Inference</a>
    </li>
    <li>
      <a href="../../articles/RB_Extended_morph/RB_MCMC_Extended_Morph.html">Discrete morphology - Relaxed Mk</a>
    </li>
    <li>
      <a href="../../articles/RB_Total_Evidence/RB_Total_Evidence_Tutorial.html">RevBayes Total Evidence Tree Estimation</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/00-installs.html">Installs</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/01-treesiftr.html">treesifter GUI</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/02-treesiftr-advanced.html">treesifter advanced</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/03-FossilSim.html">FossilSim FBD Exercise</a>
    </li>
    <li>
      <a href="../../articles/lectures/BayesianModels.html">Bayesian Models</a>
    </li>
    <li>
      <a href="../../articles/lectures/CompMethods.html">Extended Morphology Models</a>
    </li>
    <li>
      <a href="../../articles/lectures/ExtendedMorph.html">Extended Morphology Models</a>
    </li>
    <li>
      <a href="../../articles/lectures/TreeThinking.html">Tree Thinking</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Discrete morphology - Tree Inference</h1>
                        <h4 class="author">April M. Wright</h4>
                        <h4 class="author">Michael J. Landis</h4>
                        <h4 class="author">Sebastian Höhna</h4>
            
      
      
      <div class="hidden name"><code>RB_MCMC_Discrete_Morph.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>While molecular data have become the default for building phylogenetic trees for many types of evolutionary analysis, morphological data remains important, particularly for analyses involving fossils. The use of morphological data raises special considerations for model-based methods for phylogenetic inference. Morphological data are typically collected to maximize the number of parsimony-informative characters - that is, the characters that provide information in favor of one topology over another. Morphological characters also do not carry common meanings from one character in a matrix to the next; character codings are made arbitrarily. These two factors require extensions to our existing phylogenetic models. Accounting for the complexity of morphological characters remains challenging. This tutorial will provide a discussion of modeling morphological characters, and will demonstrate how to perform Bayesian phylogenetic analysis with morphology using RevBayes .</p>
<div id="overview-of-discrete-morphology-models" class="section level2">
<h2 class="hasAnchor">
<a href="#overview-of-discrete-morphology-models" class="anchor"></a>Overview of Discrete Morphology Models</h2>
<p><img src="img/tikz/Mk_model.png" alt="Mk Model"><em>Graphical model showing the Mk model (left panel).</em> <em>Rev code specifying the Mk model is on the right-hand panel.</em></p>
<p>Molecular data forms the basis of most phylogenetic analyses today. However, morphological characters remain relevant: Fossils often provide our only direct observation of extinct biodiversity; DNA degradation can make it difficult or impossible to obtain sufficient molecular data from fragile museum specimens. Using morphological data can help researchers include specimens in their phylogeny that might be left out of a molecular tree.</p>
<p>To understand how morphological characters are modeled, it is important to understand how characters are collected. Unlike in molecular data, for which homology is algorithmically determined, homology in a character is typically assessed by an expert. Biologists will typically decide what characters are homologous by looking across specimens at the same structure in multiple taxa; they may also look at the developmental origin of structures in making this assessment . Once homology is determined, characters are broken down into states, or different forms a single character can take. The state <code>0</code> commonly refers to absence, meaning that character is not present. In some codings, absence will mean that character has not evolved in that group. In others, absence means that that character has not evolved in that group, and/or that that character has been lost in that group . This type of coding is arbitrary, but both <em>non-random</em> and <em>meaningful</em>, and poses challenges for how we model the data.</p>
<p>Historically, most phylogenetic analyses using morphological characters have been performed using the maximum parsimony optimality criterion. Maximum parsimony analysis involves proposing trees from the morphological data. Each tree is evaluated according to how many changes it implied in the data, and the tree that requires the fewest changes is preferred. In this way of estimating a tree, a character that does not change, or changes only in one taxon, cannot be used to discriminate between trees (i.e., it does not favor a topology). Therefore, workers with parsimony typically do not collect characters that are parsimony uninformative.</p>
<p>In 2001, Paul Lewis  introduced a generalization of the Jukes-Cantor model of sequence evolution for use with morphological data. This model, called the Mk (Markov model, assuming each character is in one of <em>k</em> states) model provided a mathematical formulation that could be used to estimate trees from morphological data in both likelihood and Bayesian frameworks. While this model is a useful step forward, as a generalization of the Jukes-Cantor, it still makes fairly simplistic assumptions. This tutorial will guide you through estimating a phylogeny with the Mk model, and two useful extensions to the model.</p>
</div>
<div id="the-mk-model" class="section level2">
<h2 class="hasAnchor">
<a href="#the-mk-model" class="anchor"></a>The Mk Model</h2>
<p>The Mk model is a generalization of the Jukes-Cantor model of nucleotide sequence evolution, which we discussed in the <a href="https://revbayes.github.io/tutorials/ctmc/">CTMC</a> tutorial. The Q matrix for a two-state Mk model looks like so:</p>
<p><span class="math display">\[Q = \begin{pmatrix} -\mu_0 &amp; \mu_{01} \\
\mu_{10} &amp; -\mu_1  &amp;\\
\end{pmatrix} \mbox{  ,}\]</span></p>
<p>This matrix can be expanded to accommodate multi-state data, as well:</p>
<p><span class="math display">\[Q = \begin{pmatrix} -\mu_0 &amp; \mu_{01} &amp; \mu_{02} &amp; \mu_{03} \\
\mu_{10} &amp; -\mu_1  &amp; \mu_{12} &amp; \mu_{13} \\
\mu_{20} &amp; \mu_{21} &amp; -\mu_2  &amp; \mu_{23} \\
\mu_{30} &amp; \mu_{31} &amp; \mu_{32} &amp; -\mu_3 
\end{pmatrix} \mbox{  ,}\]</span></p>
<p>However, the Mk model sets transitions to be equal from any state to any other state. In that sense, our multistate matrix really looks like this:</p>
<p><span class="math display">\[Q = \begin{pmatrix} -(k-1)\mu &amp; \mu &amp; \mu &amp; \mu \\
\mu &amp; -(k-1)\mu  &amp; \mu &amp; \mu \\
\mu &amp; \mu &amp; -(k-1)\mu  &amp; \mu \\
\mu &amp; \mu &amp; \mu &amp; -(k-1)\mu \\
\end{pmatrix} \mbox{  ,}\]</span></p>
<p>Because this is a Jukes-Cantor-like model , state frequencies do not vary as a model parameter. These assumptions may seem unrealistic. However, all models are a compromise between reality and generalizability. Prior work has demonstrated that, in many conditions, the model does perform adequately . Because morphological characters do not carry common meaning across sites in a matrix in the way that nucleotide characters do, making assumptions that fit all characters is challenging. A visualization of this simple model can be seen in above graphical model.</p>
<p>We will first perform a phylogenetic analysis using the Mk model. In further sections, we will explore how to relax key assumptions of the Mk model.</p>
</div>
<div id="ascertainment-bias" class="section level2">
<h2 class="hasAnchor">
<a href="#ascertainment-bias" class="anchor"></a>Ascertainment Bias</h2>
<p>When Lewis first introduced the Mk model, he observed that branch lengths on the trees were greatly inflated. The reason for this is that when morphological characters are collected, characters that do not vary, or vary in a non-parsimony-informative way (such as autapomorphies) are excluded. Excluding these low-rate characters causes the overall amount of evolution to be over-estimated. This causes an inflation in the branch lengths .</p>
<p>Therefore, when performing a morphological phylogenetic analysis, it is important to correct for this bias. There are numerous statistically valid ways to perform this correction . Original corrections simulated invariant and non-parsimony informative characters along the proposed tree. The likelihood of these characters would then be calculated and used to normalize the total likelihood value. RevBayes implements a dynamic programming approach that calculates the same likelihood, but does so faster.</p>
<div id="example-inferring-a-phylogeny-of-fossil-and-extant-bears-using-the-mk-model" class="section level3">
<h3 class="hasAnchor">
<a href="#example-inferring-a-phylogeny-of-fossil-and-extant-bears-using-the-mk-model" class="anchor"></a>Example: Inferring a Phylogeny of Fossil And Extant Bears Using the Mk Model</h3>
<p>In this example, we will use morphological character data from extinct and extant bears (Abella et al. 2012). The dataset contains 62 binary characters, a fairly typical dataset size for morphological characters.</p>
<p><strong>Tutorial Format</strong></p>
<p>This tutorial follows a specific format for issuing instructions and information.</p>
<blockquote>
<p>The boxed instructions guide you to complete tasks that are not part of the RevBayes syntax, but rather direct you to create directories or files or similar.</p>
</blockquote>
<p>Information describing the commands and instructions will be written in paragraph-form before or after they are issued.</p>
<p>All command-line text, including all Rev syntax, are given in <code>monotype font</code>. Furthermore, blocks of Rev code that are needed to build the model, specify the analysis, or execute the run are given in separate shaded boxes. For example, we will instruct you to create a constant node called <code>example</code> that is equal to <code>1.0</code> using the <code>&lt;-</code> operator like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>    example &lt;-<span class="st"> </span><span class="fl">1.0</span></span></code></pre></div>
<p>It is important to be aware that some PDF viewers may render some characters given as differently. Thus, if you copy and paste text from this PDF, you may introduce some incorrect characters. Because of this, we recommend that you type the instructions in this tutorial or copy them from the scripts provided.</p>
<p><strong>Data and Files</strong></p>
<blockquote>
<p>On your own computer, there should be a directory called <strong>data</strong>. It should contain: <a href="data/bears.nex"><code>ants.nex</code></a>.</p>
</blockquote>
<p><strong>Getting Started</strong></p>
<blockquote>
<p>Create a new directory (in <code>DiscreteMorphology</code>) called <strong>scripts</strong>.</p>
</blockquote>
<p>When you execute RevBayes in this exercise, you will do so within the main directory (<code>APB2019</code>), thus, if you are using a Unix-based operating system, we recommend that you add the RevBayes binary to your path. Alternatively make sure that you set the working directory to, for example, <strong>APB2019</strong> if this is the directory you stored the scripts and data in.</p>
<p><strong>Creating Rev Files</strong></p>
<p>In this exercise, you will work primarily in this R text editor and create a set of files that will be easily managed and interchanged.</p>
<p>In this section you will begin the file and write the Rev commands for loading in the taxon list and managing the data matrices. Then, starting in section Mk Model, you will move on to specifying each of the model components. Once the model specifications are complete, you will complete the script with the instructions given in section</p>
<p><strong>Load Data Matrices</strong></p>
<p>RevBayes uses the function <code>readDiscreteCharacterData()</code> to load a data matrix to the workspace from a formatted file. This function can be used for both molecular sequences and discrete morphological characters. Import the morphological character matrix and assign it to the variable <code>morpho</code>. We will be using a matrix of extant and fossil data from Abella (2012).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>    morpho &lt;-<span class="st"> </span><span class="kw">readDiscreteCharacterData</span>(<span class="st">"vignettes/RB_Discrete_Morphology/data/bears_morphology.nex"</span>)</span></code></pre></div>
<p><strong>Create Helper Variables</strong></p>
<p>Before we begin writing the Rev scripts for each of the models, we need to instantiate a couple “helper variables” that will be used by downstream parts of our model specification.</p>
<p>Create a new constant node called <code>num_taxa</code> that is equal to the number of species in our analysis (41) and a constant node called <code>num_branches</code> representing the number of branches in the tree. We will also create a constant node of the taxon names. This list will be used to initialize the tree.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>    taxa &lt;-<span class="st"> </span><span class="kw">morpho.names</span>()</span>
<span id="cb3-2"><a href="#cb3-2"></a>    num_taxa &lt;-<span class="st"> </span><span class="kw">morpho.size</span>() </span>
<span id="cb3-3"><a href="#cb3-3"></a>    num_branches &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>num_taxa <span class="op">-</span><span class="st"> </span><span class="dv">2</span></span></code></pre></div>
<p>Next, create two workspace variables called <code>mvi</code> and <code>mni</code>. These variable are iterators that will build a vector containing all of the MCMC moves used to propose new states for every stochastic node in the model graph. Each time a new move is added to the vector, <code>mvi</code> will be incremented by a value of <code>1</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>    mvi =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    mni =<span class="st"> </span><span class="dv">1</span></span></code></pre></div>
<p>One important distinction here is that <code>mvi</code> is part of the RevBayes workspace and not the hierarchical model. Thus, we use the workspace assignment operator <code>=</code> instead of the constant node assignment <code>&lt;-</code>.</p>
</div>
</div>
<div id="the-mk-model-1" class="section level2">
<h2 class="hasAnchor">
<a href="#the-mk-model-1" class="anchor"></a>The Mk Model</h2>
<p>First, we will create a joint prior on the branch lengths and tree topology. This should be familiar from the {% page_ref ctmc %}</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>    br_len_lambda <span class="op">~</span><span class="st"> </span><span class="kw">dnExp</span>(<span class="fl">0.2</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>    moves[mvi<span class="op">++</span>] =<span class="st"> </span><span class="kw">mvScale</span>(br_len_lambda, <span class="dt">weight=</span><span class="dv">2</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>    phylogeny <span class="op">~</span><span class="st"> </span><span class="kw">dnUniformTopologyBranchLength</span>(taxa, <span class="dt">branchLengthDistribution=</span><span class="kw">dnExponential</span>(br_len_lambda))</span>
<span id="cb5-5"><a href="#cb5-5"></a>    moves[mvi<span class="op">++</span>] =<span class="st"> </span><span class="kw">mvNNI</span>(phylogeny, <span class="dt">weight=</span>num_branches<span class="op">/</span><span class="fl">2.0</span>)</span>
<span id="cb5-6"><a href="#cb5-6"></a>    moves[mvi<span class="op">++</span>] =<span class="st"> </span><span class="kw">mvSPR</span>(phylogeny, <span class="dt">weight=</span>num_branches<span class="op">/</span><span class="fl">10.0</span>)</span>
<span id="cb5-7"><a href="#cb5-7"></a>    moves[mvi<span class="op">++</span>] =<span class="st"> </span><span class="kw">mvBranchLengthScale</span>(phylogeny, <span class="dt">weight=</span>num_branches)</span>
<span id="cb5-8"><a href="#cb5-8"></a>    </span>
<span id="cb5-9"><a href="#cb5-9"></a>    tree_length <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">phylogeny.treeLength</span>()</span></code></pre></div>
<p>Next, we will create a <span class="math inline">\(Q\)</span> matrix. Recall that the Mk model is simply a generalization of the JC model. Therefore, we will create a 2x2 <span class="math inline">\(Q\)</span> matrix using <code>fnJC</code>, which initializes Q-matrices with equal transition probabilities between all states.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>    Q_morpho &lt;-<span class="st"> </span><span class="kw">fnJC</span>(<span class="dv">2</span>)</span></code></pre></div>
<p>Now that we have the basics of the model specified, we will add Gamma-distributed rate variation and specify moves on the parameter to the Gamma distribution.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>Q_morpho</span></code></pre></div>
<pre><code>   [ [ -1.0000, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667 ] ,
     0.1667, -1.0000, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667 ] ,
     0.1667, 0.1667, -1.0000, 0.1667, 0.1667, 0.1667, 0.1667 ] ,
     0.1667, 0.1667, 0.1667, -1.0000, 0.1667, 0.1667, 0.1667 ] ,
     0.1667, 0.1667, 0.1667, 0.1667, -1.0000, 0.1667, 0.1667 ] ,
     0.1667, 0.1667, 0.1667, 0.1667, 0.1667, -1.0000, 0.1667 ] ,
     0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667, -1.0000 ] ]</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>    alpha_morpho <span class="op">~</span><span class="st"> </span><span class="kw">dnUniform</span>( <span class="dv">0</span>, <span class="fl">1E6</span> )</span>
<span id="cb9-2"><a href="#cb9-2"></a>    rates_morpho <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">fnDiscretizeGamma</span>( alpha_morpho, alpha_morpho, <span class="dv">4</span> )</span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="co">#Moves on the parameters to the Gamma distribution.</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    moves[mvi<span class="op">++</span>] =<span class="st"> </span><span class="kw">mvScale</span>(alpha_morpho, <span class="dt">lambda=</span><span class="dv">1</span>, <span class="dt">weight=</span><span class="fl">2.0</span>)</span></code></pre></div>
<p>Lastly, we set up the CTMC.</p>
<p>We see some familiar pieces: tree, <span class="math inline">\(Q\)</span> matrix and site_rates. We also have two new keywords: data type and coding. The data type argument specifies the type of data - in our case, “Standard”, the specification for morphology.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>    phyMorpho <span class="op">~</span><span class="st"> </span><span class="kw">dnPhyloCTMC</span>(<span class="dt">tree=</span>phylogeny, <span class="dt">siteRates=</span>rates_morpho, <span class="dt">Q=</span>Q_morpho, <span class="dt">type=</span><span class="st">"Standard"</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">phyMorpho.clamp</span>(morpho)</span></code></pre></div>
<p>All of the components of the model are now specified.</p>
<div id="complete-mcmc-analysis" class="section level3">
<h3 class="hasAnchor">
<a href="#complete-mcmc-analysis" class="anchor"></a>Complete MCMC Analysis</h3>
<p><strong>Create Model Object</strong></p>
<p>We can now create our workspace model variable with our fully specified model DAG. We will do this with the <code>model()</code> function and provide a single node in the graph (<code>phylogeny</code>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>    mymodel =<span class="st"> </span><span class="kw">model</span>(phylogeny)</span></code></pre></div>
<p>The object <code>mymodel</code> is a wrapper around the entire model graph and allows us to pass the model to various functions that are specific to our MCMC analysis.</p>
<p><strong>Specify Monitors and Output Filenames</strong></p>
<p>The next important step for our Rev-script is to specify the monitors and output file names. For this, we create a vector called <code>monitors</code> that will each sample and record or output our MCMC.</p>
<p>The first monitor we will create will monitor every named random variable in our model graph. This will include every stochastic and deterministic node using the <code>mnModel</code> monitor. The only parameter that is not included in the <code>mnModel</code> is the tree topology. Therefore, the parameters in the file written by this monitor are all numerical parameters written to a tab-separated text file that can be opened by accessory programs for evaluating such parameters. We will also name the output file for this monitor and indicate that we wish to sample our MCMC every 10 cycles.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>    monitors[mni<span class="op">++</span>] =<span class="st"> </span><span class="kw">mnModel</span>(<span class="dt">filename=</span><span class="st">"output/mk_gamma.log"</span>, <span class="dt">printgen=</span><span class="dv">10</span>)</span></code></pre></div>
<p>The <code>mnFile</code> monitor writes any parameter we specify to file. Thus, if we only cared about the branch lengths and nothing else (this is not a typical or recommended attitude for an analysis this complex) we wouldn’t use the <code>mnModel</code> monitor above and just use the <code>mnFile</code> monitor to write a smaller and simpler output file. Since the tree topology is not included in the <code>mnModel</code> monitor (because it is not numerical), we will use <code>mnFile</code> to write the tree to file by specifying our <code>phylogeny</code> variable in the arguments.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>    monitors[mni<span class="op">++</span>] =<span class="st"> </span><span class="kw">mnFile</span>(<span class="dt">filename=</span><span class="st">"output/mk_gamma.trees"</span>, <span class="dt">printgen=</span><span class="dv">10</span>, phylogeny)</span></code></pre></div>
<p>The third monitor we will add to our analysis will print information to the screen. Like with <code>mnFile</code> we must tell <code>mnScreen</code> which parameters we’d like to see updated on the screen.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>    monitors[mni<span class="op">++</span>] =<span class="st"> </span><span class="kw">mnScreen</span>(<span class="dt">printgen=</span><span class="dv">100</span>)</span></code></pre></div>
</div>
<div id="set-up-the-mcmc" class="section level3">
<h3 class="hasAnchor">
<a href="#set-up-the-mcmc" class="anchor"></a>Set-Up the MCMC</h3>
<p>Once we have set up our model, moves, and monitors, we can now create the workspace variable that defines our MCMC run. We do this using the <code>mcmc()</code> function that simply takes the three main analysis components as arguments.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>    mymcmc =<span class="st"> </span><span class="kw">mcmc</span>(mymodel, monitors, moves, <span class="dt">nruns=</span><span class="dv">2</span>, <span class="dt">combine=</span><span class="st">"mixed"</span>)</span></code></pre></div>
<p>The MCMC object that we named <code>mymcmc</code> has a member method called <code>.run()</code>. This will execute our analysis and we will set the chain length to <code>10000</code> cycles using the <code>generations</code> option.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>    <span class="kw">mymcmc.run</span>(<span class="dt">generations=</span><span class="dv">10000</span>, <span class="dt">tuningInterval=</span><span class="dv">200</span>)</span></code></pre></div>
<p>Once our Markov chain has terminated, we will want RevBayes to close. Tell the program to quit using the <code><a href="https://www.rdocumentation.org/packages/base/topics/quit">q()</a></code> function.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>    <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/quit">q</a></span>()</span></code></pre></div>
</div>
</div>
<div id="you-made-it-save-all-of-your-files-" class="section level2">
<h2 class="hasAnchor">
<a href="#you-made-it-save-all-of-your-files-" class="anchor"></a>You made it! Save all of your files.</h2>
<p>With all the parameters specified and all analysis components in place, you are now ready to run your analysis. RevBayes cannot run inside the RStudio window. So we will need to copy our code out of RStudio. Luckily, the knitr package makes this very easy. Run the following in the console:</p>
<pre><code><a href="https://www.rdocumentation.org/packages/knitr/topics/knit">knitr::purl("vignettes/RB_Discrete_Morphology/RB_MCMC_Discrete_Morph.Rmd")</a></code></pre>
<p>This will create a .R file containing our analysis script. Move it into the <code>scripts</code> folder and rename it to mk_gamma.Rev</p>
<blockquote>
<p>Begin by running the RevBayes executable. In Unix systems, type the following in your terminal (if the RevBayes binary is in your path): rb</p>
</blockquote>
<p>Provided that you started RevBayes from the correct directory, you can then use the <code><a href="https://www.rdocumentation.org/packages/base/topics/source">source()</a></code> function to feed RevBayes your Rev-script file (<code>mk_gamma.Rev</code>).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>    <span class="bu">source</span>(<span class="st">"scripts/mk_gamma.Rev"</span>)</span></code></pre></div>
<p>When the analysis is complete, RevBayes will quit and you will have a new directory called <code>output</code> that will contain all of the files you specified with the monitors.</p>
<div id="lognormally-distributed-among-character-rate-variation" class="section level4">
<h4 class="hasAnchor">
<a href="#lognormally-distributed-among-character-rate-variation" class="anchor"></a>Lognormally-distributed among-character rate variation</h4>
<p>As we discussed, there is reason to believe a lognormal distribution may fit morphological data better than a gamma. RevBayes makes it very natural to discretize <em>any</em> distribution you might like to work with.</p>
<pre><code>
    rates_morpho := fnDiscretizeDistribution( dnLognormal(ln(alpha_morpho), 0.01), 4 )</code></pre>
<p>Can you figure out which line you might replace with this code? Do it, and change your output files to indicate that this is estimation uses a lognormal distribution. Re-run your Rev script.</p>
</div>
<div id="ascertainment-bias-1" class="section level4">
<h4 class="hasAnchor">
<a href="#ascertainment-bias-1" class="anchor"></a>Ascertainment Bias</h4>
<p>As discussed earlier in the section Ascertainment_Bias, we also need to correct for ascertainment bias.</p>
<blockquote>
<p>Create a copy of your previous <code>Rev</code> script, and call it <em>mcmc_Mkv.Rev</em>. You will need to modify the <code>Rev</code> code provided in this section in this file.</p>
</blockquote>
<p>In <code>RevBayes</code> it is actually very simple to add a correction for ascertainment bias. You only need to set the option <code>coding="variable"</code> in the <code>dnPhyloCTMC</code>. Coding specifies what type of ascertainment bias is expected. We are using the <code>variable</code> correction, as we have no invariant character in our matrix. If we also lacked parsimony non-informative characters, we would use the coding <code>informative</code>.</p>
<pre><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho, Q=Q_morpho, type="Standard", coding="variable")</code></pre>
</div>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#introduction">Introduction</a><ul class="nav nav-pills nav-stacked">
<li><a href="#overview-of-discrete-morphology-models">Overview of Discrete Morphology Models</a></li>
      <li><a href="#the-mk-model">The Mk Model</a></li>
      <li><a href="#ascertainment-bias">Ascertainment Bias</a></li>
      <li><a href="#the-mk-model-1">The Mk Model</a></li>
      <li><a href="#you-made-it-save-all-of-your-files-">You made it! Save all of your files.</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by April Wright.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
