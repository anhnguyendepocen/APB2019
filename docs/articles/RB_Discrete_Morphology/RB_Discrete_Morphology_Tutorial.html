<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RevBayes Discrete Morphology Tree Estimation • apb2018</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><meta property="og:title" content="RevBayes Discrete Morphology Tree Estimation">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../../index.html">apb2018</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/RB_Discrete_Morphology/RB_Discrete_Morphology_Tutorial.html">RevBayes Discrete Morphology Tree Estimation</a>
    </li>
    <li>
      <a href="../../articles/RB_Total_Evidence/RB_Total_Evidence_Tutorial.html">RevBayes Total Evidence Tree Estimation</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/00-installs.html">Installs</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/01-treesiftr.html">treesifter</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/02-treesiftr-advanced.html">treesifter advanced</a>
    </li>
    <li>
      <a href="../../articles/R_exercises/03-FossilSim.html">FossilSim FBD Exercise</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>RevBayes Discrete Morphology Tree Estimation</h1>
            
      
      
      <div class="hidden name"><code>RB_Discrete_Morphology_Tutorial.Rmd</code></div>

    </div>

    
    
<p><strong>Phylogenetic Inference using <span><code>RevBayes</code></span></strong><br><strong><em><span>Discrete Morphology</span></em></strong><br></p>
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>While molecular data have become the default for building phylogenetic trees for many types of evolutionary analysis, morphological data remains important, particularly for analyses involving fossils. The use of morphological data raises special considerations for model-based methods for phylogenetic inference. Morphological data are typically collected to maximize the number of parsimony-informative characters - that is, the characters that provide information in favor of one topology over another. Morphological characters also do not carry common meanings from one character in a matrix to the next; character codings are made arbitrarily. These two factors require extensions to our existing phylogenetic models. Accounting for the complexity of morphological characters remains challenging. This tutorial will provide a discussion of modeling morphological characters, and will demonstrate how to perform Bayesian phylogenetic analysis with morphology using <span><code>RevBayes</code></span><span class="citation">(Höhna et al. 2016)</span>.</p>
<div id="contents" class="section level2">
<h2 class="hasAnchor">
<a href="#contents" class="anchor"></a>Contents</h2>
<p>The Discrete Morphology guide contains several tutorials</p>
<ul>
<li><p>Section: Overview of the Discrete Morphological models</p></li>
<li><p>Section: A simple discrete morphology analysis</p></li>
<li><p>Section: A model for allowing state frequency variation across binary characters</p></li>
<li><p>Section: A model for allowing state frequency variation across binary and multistate characters</p></li>
<li><p>Section: Evaluating the MCMC</p></li>
</ul>
</div>
<div id="recommended-tutorials" class="section level2">
<h2 class="hasAnchor">
<a href="#recommended-tutorials" class="anchor"></a>Recommended tutorials</h2>
<p>The Discrete Morphology tutorials assume the reader is familiar with the content covered in the following <span><code>RevBayes</code></span>tutorials</p>
<ul>
<li><p><span><strong><span><code>Rev</code></span>Basics</strong></span></p></li>
<li><p><span><strong>Molecular Models of Character Evolution</strong></span></p></li>
<li><p><span><strong>Running and Diagnosing an MCMC Analysis</strong></span></p></li>
<li><p><span><strong>Divergence Time Estimation and Node Calibrations</strong></span></p></li>
</ul>
</div>
</div>
<div id="overview-of-discrete-morphology-models" class="section level1">
<h1 class="hasAnchor">
<a href="#overview-of-discrete-morphology-models" class="anchor"></a>Overview of Discrete Morphology Models</h1>
<div class="figure">
<img src="figures/tikz/Mk_model.png" alt="Mk Model"><p class="caption">Mk Model</p>
</div>
<p>Molecular data forms the basis of most phylogenetic analyses today. However, morphological characters remain relevant: Fossils often provide our only direct observation of extinct biodiversity; DNA degradation can make it difficult or impossible to obtain sufficient molecular data from fragile museum specimens. Using morphological data can help researchers include specimens in their phylogeny that might be left out of a molecular tree.</p>
<p>To understand how morphological characters are modeled, it is important to understand how characters are collected. Unlike in molecular data, for which homology is algorithmically determined, homology in a character is typically assessed by an expert. Biologists will typically decide what characters are homologous by looking across specimens at the same structure in multiple taxa; they may also look at the developmental origin of structures in making this assessment <span class="citation">(Phillips 2006)</span>. Once homology is determined, characters are broken down into states, or different forms a single character can take. The state ‘0’ commonly refers to absence, meaning that character is not present. In some codings, absence will mean that character has not evolved in that group. In others, absence means that that character has not evolved in that group, and/or that that character has been lost in that group <span class="citation">(Freudenstein 2005)</span>. This type of coding is arbitrary, but both <strong>non-random</strong> and <strong>meaningful</strong>, and poses challenges for how we model the data.</p>
<p>Historically, most phylogenetic analyses using morphological characters have been performed using the maximum parsimony optimality criterion. Maximum parsimony analysis involves proposing trees from the morphological data. Each tree is evaluated according to how many changes it implied in the data, and the tree that requires the fewest changes is preferred. In this way of estimating a tree, a character that does not change, or changes only in one taxon, cannot be used to discriminate between trees (i.e., it does not favor a topology). Therefore, workers with parsimony typically do not collect characters that are parsimony uninformative.</p>
<p>In 2001, Paul Lewis <span class="citation">(Lewis 2001)</span> introduced a generalization of the Jukes-Cantor model of sequence evolution for use with morphological data. This model, called the Mk (Markov model, assuming each character is in one of <em>k</em> states) model provided a mathematical formulation that could be used to estimate trees from morphological data in both likelihood and Bayesian frameworks. While this model is a useful step forward, as a generalization of the Jukes-Cantor, it still makes fairly simplistic assumptions. This tutorial will guide you through estimating a phylogeny with the Mk model, and two useful extensions to the model.</p>
<div id="the-mk-model" class="section level2">
<h2 class="hasAnchor">
<a href="#the-mk-model" class="anchor"></a>The Mk Model</h2>
<p>The Mk model is a generalization of the Jukes-Cantor model of nucleotide sequence evolution, which we discussed in <strong>Molecular Models of Character Evolution</strong>. The Q matrix for a two-state Mk model looks like so:</p>
<p><span class="math display">\[Q = \begin{pmatrix} -\mu_0 &amp; \mu_{01} \\
\mu_{10} &amp; -\mu_1  &amp;\\
\end{pmatrix} \mbox{  ,}\]</span></p>
<p>This matrix can be expanded to accommodate multi-state data, as well:</p>
<p><span class="math display">\[Q = \begin{pmatrix} -\mu_0 &amp; \mu_{01} &amp; \mu_{02} &amp; \mu_{03} \\
\mu_{10} &amp; -\mu_1  &amp; \mu_{12} &amp; \mu_{13} \\
\mu_{20} &amp; \mu_{21} &amp; -\mu_2  &amp; \mu_{23} \\
\mu_{30} &amp; \mu_{31} &amp; \mu_{32} &amp; -\mu_3 
\end{pmatrix} \mbox{  ,}\]</span></p>
<p>However, the Mk model sets transitions to be equal from any state to any other state. In that sense, our multistate matrix really looks like this:</p>
<p><span class="math display">\[Q = \begin{pmatrix} -(k-1)\mu &amp; \mu &amp; \mu &amp; \mu \\
\mu &amp; -(k-1)\mu  &amp; \mu &amp; \mu \\
\mu &amp; \mu &amp; -(k-1)\mu  &amp; \mu \\
\mu &amp; \mu &amp; \mu &amp; -(k-1)\mu \\
\end{pmatrix} \mbox{  ,}\]</span></p>
<p>Because this is a Jukes-Cantor-like model <span class="citation">(Jukes and Cantor 1969)</span>, state frequencies do not vary as a model parameter. These assumptions may seem unrealistic. However, all models are a compromise between reality and generalizability. Prior work has demonstrated that, in many conditions, the model does perform adequately <span class="citation">(Wright and Hillis 2014)</span>. Because morphological characters do not carry common meaning across sites in a matrix in the way that nucleotide characters do, making assumptions that fit all characters is challenging. A visualization of this simple model can be seen in Fig. 2.   .</p>
<p>We will first perform a phylogenetic analysis using the Mk model. In further sections, we will explore how to relax key assumptions of the Mk model.</p>
</div>
<div id="ascertainment-bias" class="section level2">
<h2 class="hasAnchor">
<a href="#ascertainment-bias" class="anchor"></a>Ascertainment Bias</h2>
<p>When Lewis first introduced the Mk model, he observed that branch lengths on the trees were greatly inflated. The reason for this is that when morphological characters are collected, characters that do not vary, or vary in a non-parsimony-informative way (such as autapomorphies) are excluded. Excluding these low-rate characters causes the overall amount of evolution to be over-estimated. This causes an inflation in the branch lengths <span class="citation">(Lewis 2001)</span>.</p>
<p>Therefore, when performing a morphological phylogenetic analysis, it is important to correct for this bias. There are numerous statistically valid ways to perform this correction <span class="citation">(Allman and Rhodes 2008)</span>. Original corrections simulated invariant and non-parsimony informative characters along the proposed tree. The likelihood of these characters would then be calculated and used to normalize the total likelihood value. <span><code>RevBayes</code></span>implements a dynamic programming approach that calculates the same likelihood, but does so faster.</p>
</div>
</div>
<div id="example-inferring-a-phylogeny-of-fossil-bears-using-the-mk-model" class="section level1">
<h1 class="hasAnchor">
<a href="#example-inferring-a-phylogeny-of-fossil-bears-using-the-mk-model" class="anchor"></a>Example: Inferring a Phylogeny of Fossil Bears Using the Mk Model</h1>
<p>In this example, we will use morphological character data from 18 taxa of extinct bears <span class="citation">(Abella, Montoya, and Morales 2011)</span>. The dataset contains 62 binary characters, a fairly typical dataset size for morphological characters.</p>
<div id="tutorial-format" class="section level2">
<h2 class="hasAnchor">
<a href="#tutorial-format" class="anchor"></a>Tutorial Format</h2>
<p>This tutorial follows a specific format for issuing instructions and information.</p>
<p>The boxed instructions guide you to complete tasks that are not part of the <span><code>RevBayes</code></span>syntax, but rather direct you to create directories or files or similar.</p>
<p>Information describing the commands and instructions will be written in paragraph-form before or after they are issued.</p>
<p>All command-line text, including all <span><code>Rev</code></span>syntax, are given in <span><span><code>monotype font</code></span></span>. Furthermore, blocks of <span><code>Rev</code></span>code that are needed to build the model, specify the analysis, or execute the run are given in separate shaded boxes. For example, we will instruct you to create a constant node called <span><span><code>example</code></span></span> that is equal to <span><span><code>1.0</code></span></span> using the <span><span><code>&lt;-</code></span></span> operator like this:</p>
<pre><code>example &lt;- 1.0</code></pre>
<p>It is important to be aware that some PDF viewers may render some characters given as differently. Thus, if you copy and paste text from this PDF, you may introduce some incorrect characters. Because of this, we recommend that you type the instructions in this tutorial or copy them from the scripts provided.</p>
</div>
<div id="getting-started" class="section level2">
<h2 class="hasAnchor">
<a href="#getting-started" class="anchor"></a>Getting Started }</h2>
<p>Create a new directory (in the APB2018 repository called <span><span><code>RB_DiscreteMorphology_Tutorial</code></span></span>.</p>
<p>When you execute <span><code>RevBayes</code></span>in this exercise, you will do so within the main directory you created, (<span><span><code>RB_DiscreteMorphology_Tutorial</code></span></span>), thus, if you are using a Unix-based operating system, we recommend that you add the <span><code>RevBayes</code></span>binary to your path.</p>
</div>
<div id="creating-revfiles" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-revfiles" class="anchor"></a>Creating <span><code>Rev</code></span>Files</h2>
<p>For complex models and analyses, it is best to create <span><code>Rev</code></span>script files that will contain all of the model parameters, moves, and functions. In this exercise, you will work primarily in your text editor[^1] and create a set of modular files that will be easily managed and interchanged. In this first section, you will write the following files from scratch and save them in the <span><span><code>scripts</code></span></span> directory:</p>
<ul>
<li><p><span><span><code>mcmc_mk.Rev</code></span></span>: the master <span><code>Rev</code></span>file that loads the data, the separate model files, and specifies the monitors and MCMC sampler.</p></li>
<li><p><span><span><code>model_mk.Rev</code></span></span>: specifies the model describing discrete morphological character change (binary characters).</p></li>
</ul>
<p>All of the files that you will create are also provided in the <span><code>RevBayes</code></span>tutorial repository[^2]. Please refer to these files to verify or troubleshoot your own scripts.</p>
<p>Open your text editor and create the master <span><code>Rev</code></span>file called in the <span><span><code>scripts</code></span></span> directory.</p>
<p>Enter the <span><code>Rev</code></span>code provided in this section in the new model file.</p>
<p>The file you will begin in this section will be the one you load into <span><code>RevBayes</code></span>when you’ve completed all of the components of the analysis. In this section you will begin the file and write the <span><code>Rev</code></span>commands for loading in the taxon list and managing the data matrices. Then, starting in section Exercise - Mk Model, you will move on to writing module files for each of the model components. Once the model files are complete, you will return to editing <span><span><code>mcmc_Mk.Rev</code></span></span> and complete the <span><code>Rev</code></span>script with the instructions given in section Exercise - Complete MCMC.</p>
<div id="load-data-matrices" class="section level3">
<h3 class="hasAnchor">
<a href="#load-data-matrices" class="anchor"></a>Load Data Matrices</h3>
<p><span><code>RevBayes</code></span>uses the function <span><span><code>readDiscreteCharacterData()</code></span></span> to load a data matrix to the workspace from a formatted file. This function can be used for both molecular sequences and discrete morphological characters. Import the morphological character matrix and assign it to the variable <span><span><code>morpho</code></span></span>.</p>
<pre><code>morpho &lt;- readDiscreteCharacterData("data/bears.nex")</code></pre>
</div>
<div id="create-helper-variables" class="section level3">
<h3 class="hasAnchor">
<a href="#create-helper-variables" class="anchor"></a>Create Helper Variables</h3>
<p>Before we begin writing the <span><code>Rev</code></span>scripts for each of the model components, we need to instantiate a couple “helper variables” that will be used by downstream parts of our model specification files. These variables will be used in more than one of the module files so it’s best to initialize them in the master file.</p>
<p>Create a new constant node called <span><span><code>n_taxa</code></span></span> that is equal to the number of species in our analysis (18). We will also create a constant node of the taxon names. This list will be used to initialize the tree.</p>
<pre><code>names &lt;- morpho.names()
n_taxa &lt;- morpho.size() </code></pre>
<p>Next, create a workspace variable called <span><span><code>mvi</code></span></span>. This variable is an iterator that will build a vector containing all of the MCMC moves used to propose new states for every stochastic node in the model graph. Each time a new move is added to the vector, <span><span><code>mvi</code></span></span> will be incremented by a value of <span><span><code>1</code></span></span>.</p>
<pre><code>mvi = 1</code></pre>
<p>One important distinction here is that <span><span><code>mvi</code></span></span> is part of the <span><code>RevBayes</code></span>workspace and not the hierarchical model. Thus, we use the workspace assignment operator <span><span><code>=</code></span></span> instead of the constant node assignment <span><span><code>&lt;-</code></span></span>.</p>
<p>Save your current working version of <span><span><code>mcmc_Mk.Rev</code></span></span> in the <span><span><code>scripts</code></span></span> directory.</p>
<p>We will now move on to the next <span><code>Rev</code></span>file and will return to <span><span><code>mcmc_Mk.Rev</code></span></span> in section Exercise - Complete MCMC.</p>
</div>
</div>
<div id="subsect:Exercise-MkModel" class="section level2">
<h2 class="hasAnchor">
<a href="#subsect:Exercise-MkModel" class="anchor"></a>The Mk Model</h2>
<p>Open your text editor and create the master <span><code>Rev</code></span>file called in the <span><span><code>scripts</code></span></span> directory.</p>
<p>Enter the <span><code>Rev</code></span>code provided in this section in the new model file.</p>
<p>First, we will create a vector of moves on branch lengths. This should be familiar from the <span><span><code>RB_CTMC</code></span></span> tutorial:</p>
<pre><code>br_len_lambda ~ dnExp(0.2)
moves[mvi++] = mvScale(br_len_lambda, weight=5)
nbr &lt;- 2*names.size() - 3
for (i in 1:nbr){
    br_lens[i] ~ dnExponential(br_len_lambda)
    moves[mvi++] = mvScale(br_lens[i]) 
}</code></pre>
<p>Next, we will create a Q matrix. Recall that the Mk model is simply a generalization of the JC model. Therefore, we will create a 2x2 Q matrix using <span><span><code>fnJC</code></span></span>, which initializes Q-matrices with equal transition probabilities between all states.</p>
<pre><code>Q_morpho &lt;- fnJC(2)</code></pre>
<p>Now that we have the basics of the model specified, we will add Gamma-distributed rate variation and specify moves on the parameter to the Gamma distribution.</p>
<pre><code>alpha_morpho ~ dnExponential( 1.0 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

#Moves on the parameters to the Gamma distribution.
moves[mvi++] = mvScale(alpha_morpho, lambda=0.01, weight=5.0)
moves[mvi++] = mvScale(alpha_morpho, lambda=0.1,  weight=3.0)
moves[mvi++] = mvScale(alpha_morpho, lambda=1,    weight=1.0)</code></pre>
<p>Next we assemble the tree and specify a move on the topology.</p>
<pre><code>tau ~ dnUniformTopology(names)
phylogeny := treeAssembly(tau, br_lens)
moves[mvi++] = mvNNI(tau, weight=2*nbr)
moves[mvi++] = mvSPR(tau, weight=nbr)
tree_length := phylogeny.treeLength()</code></pre>
<p>Lastly, we set up the CTMC. This should be familiar from the <span><span><code>RB_CTMC</code></span></span> tutorial. We see some familiar pieces: tree, Q matrix and site_rates. We also have two new keywords: data type and coding. The data type argument specifies the type of data - in our case, “Standard”, the specification for morphology. Coding specifies what type of ascertainment bias is expected. We are using the ‘variable’ correction, as we have no invariant character in our matrix. If we also lacked parsimony non-informative characters, we would use the coding ‘informative’.</p>
<pre><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho, Q=Q_morpho, type="Standard", coding="variable")
phyMorpho.clamp(morpho)</code></pre>
<p>All of the components of the model are now specified.</p>
</div>
<div id="complete-master-revfile" class="section level2">
<h2 class="hasAnchor">
<a href="#complete-master-revfile" class="anchor"></a>Complete Master <span><code>Rev</code></span>File</h2>
<p>Return to the master <span><code>Rev</code></span>file called in the <span><span><code>scripts</code></span></span> directory.</p>
<p>Enter the <span><code>Rev</code></span>code provided in this section in this file.</p>
<div id="source-model-scripts" class="section level3">
<h3 class="hasAnchor">
<a href="#source-model-scripts" class="anchor"></a>Source Model Scripts</h3>
<p><span><code>RevBayes</code></span>uses the <span><span><code>source()</code></span></span> function to load commands from <span><code>Rev</code></span>files into the workspace. Use this function to load in the model scripts we have written in the text editor and saved in the <span><span><code>scripts</code></span></span> directory.</p>
<pre><code>source("scripts/model_Mk.Rev")</code></pre>
</div>
<div id="create-model-object" class="section level3">
<h3 class="hasAnchor">
<a href="#create-model-object" class="anchor"></a>Create Model Object</h3>
<p>We can now create our workspace model variable with our fully specified model DAG. We will do this with the <span><span><code>model()</code></span></span> function and provide a single node in the graph (<span><span><code>phylogeny</code></span></span>).</p>
<pre><code>mymodel = model(phylogeny)</code></pre>
<p>The object <span><span><code>mymodel</code></span></span> is a wrapper around the entire model graph and allows us to pass the model to various functions that are specific to our MCMC analysis.</p>
</div>
<div id="specify-monitors-and-output-filenames" class="section level3">
<h3 class="hasAnchor">
<a href="#specify-monitors-and-output-filenames" class="anchor"></a>Specify Monitors and Output Filenames</h3>
<p>The next important step for our master <span><code>Rev</code></span>file is to specify the monitors and output file names. For this, we create a vector called <span><span><code>monitors</code></span></span> that will each sample and record or output our MCMC.</p>
<p>First, we will specify a workspace variable to iterate over the <span><span><code>monitors</code></span></span> vector.</p>
<pre><code>mni = 1</code></pre>
<p>The first monitor we will create will monitor every named random variable in our model graph. This will include every stochastic and deterministic node using the <span><span><code>mnModel</code></span></span> monitor. The only parameter that is not included in the <span><span><code>mnModel</code></span></span> is the tree topology. Therefore, the parameters in the file written by this monitor are all numerical parameters written to a tab-separated text file that can be opened by accessory programs for evaluating such parameters. We will also name the output file for this monitor and indicate that we wish to sample our MCMC every 10 cycles.</p>
<pre><code>monitors[mni++] = mnModel(filename="output/mk_simple.log", printgen=10)</code></pre>
<p>The <span><span><code>mnFile</code></span></span> monitor writes any parameter we specify to file. Thus, if we only cared about the branch lengths and nothing else (this is not a typical or recommended attitude for an analysis this complex) we wouldn’t use the <span><span><code>mnModel</code></span></span> monitor above and just use the <span><span><code>mnFile</code></span></span> monitor to write a smaller and simpler output file. Since the tree topology is not included in the <span><span><code>mnModel</code></span></span> monitor (because it is not numerical), we will use <span><span><code>mnFile</code></span></span> to write the tree to file by specifying our <span><span><code>phylogeny</code></span></span> variable in the arguments.</p>
<pre><code>monitors[mni++] = mnFile(filename="output/mk_simple.trees", printgen=10, phylogeny)</code></pre>
<p>The third monitor we will add to our analysis will print information to the screen. Like with <span><span><code>mnFile</code></span></span> we must tell <span><span><code>mnScreen</code></span></span> which parameters we’d like to see updated on the screen.</p>
<pre><code>monitors[mni++] = mnScreen(printgen=10)</code></pre>
</div>
<div id="set-up-the-mcmc" class="section level3">
<h3 class="hasAnchor">
<a href="#set-up-the-mcmc" class="anchor"></a>Set-Up the MCMC</h3>
<p>Once we have set up our model, moves, and monitors, we can now create the workspace variable that defines our MCMC run. We do this using the <span><span><code>mcmc()</code></span></span> function that simply takes the three main analysis components as arguments.</p>
<pre><code>mymcmc = mcmc(mymodel, monitors, moves)</code></pre>
<p>The MCMC object that we named <span><span><code>mymcmc</code></span></span> has a member method called <span><span><code>.run()</code></span></span>. This will execute our analysis and we will set the chain length to <span><span><code>10000</code></span></span> cycles using the <span><span><code>generations</code></span></span> option.</p>
<pre><code>mymcmc.run(generations=20000)</code></pre>
<p>Once our Markov chain has terminated, we will want <span><code>RevBayes</code></span>to close. Tell the program to quit using the <span><span><code>q()</code></span></span> function.</p>
<pre><code>q()</code></pre>
<p>You made it! Save all of your files.</p>
</div>
</div>
<div id="execute-the-mcmc-analysis" class="section level2">
<h2 class="hasAnchor">
<a href="#execute-the-mcmc-analysis" class="anchor"></a>Execute the MCMC Analysis</h2>
<p>With all the parameters specified and all analysis components in place, you are now ready to run your analysis. The <span><code>Rev</code></span>scripts you just created will all be used by <span><code>RevBayes</code></span>and loaded in the appropriate order.</p>
<p>Begin by running the <span><code>RevBayes</code></span>executable. In Unix systems, type the following in your terminal (if the <span><code>RevBayes</code></span>binary is in your path):</p>
<p>Provided that you started <span><code>RevBayes</code></span>from the correct directory (<span><span><code>RB_DiscreteMorphology_Tutorial</code></span></span>), you can then use the <span><span><code>source()</code></span></span> function to feed <span><code>RevBayes</code></span>your master script file (<span><span><code>mcmc_mk.Rev</code></span></span>).</p>
<pre><code>source("scripts/mcmc_mk.Rev")</code></pre>
<p>This will execute the analysis and you should see the following output (though not the exact same values):</p>
<p>When the analysis is complete, <span><code>RevBayes</code></span>will quit and you will have a new directory called <span><span><code>output</code></span></span> that will contain all of the files you specified with the monitors (Sect. Exercise - Monitors).</p>
<div id="ascertainment-bias" class="section level3">
<h3 class="hasAnchor">
<a href="#ascertainment-bias" class="anchor"></a>Ascertainment Bias</h3>
<p>As discussed in (Sect. Ascertainment Bias), we also need to correct for ascertainment bias. Once your initial Mk model estimation, source the mcmc_simple.Rev script. This file is an estimation of the Mk model without any correction for ascertainment bias. We will use this for comparison in a moment.</p>
</div>
</div>
</div>
<div id="break-lecture" class="section level1">
<h1 class="hasAnchor">
<a href="#break-lecture" class="anchor"></a>BREAK: Lecture</h1>
</div>
<div id="example-relaxing-the-assumption-of-equal-transition-probabilities" class="section level1">
<h1 class="hasAnchor">
<a href="#example-relaxing-the-assumption-of-equal-transition-probabilities" class="anchor"></a>Example: Relaxing the Assumption of Equal Transition Probabilities</h1>
<p>Make a copy of the MCMC and model files you made earlier. Call them <span><span><code>mcmc_mk_dicretized.Rev</code></span></span> and <span><span><code>model_mk_discretized.Rev</code></span></span>. These will contain the new model parameters and models.</p>
<div class="figure">
<img src="figures/tikz/morpho_gm.png" alt="Mk Model"><p class="caption">Mk Model</p>
</div>
<p>The Mk model makes a number of assumptions, but one that may strike you as unrealistic is the assumption that characters are equally likely to change from any one state to any other state. That means that a trait is as likely to be gained as lost. While this may hold true for some traits, we expect that it may be untrue for many others.</p>
<p><span><code>RevBayes</code></span>has functionality to allow us to relax this assumption. We do this by specifying a Beta prior on state frequencies. Remember from the <span><span><code>RB_CTMC</code></span></span> lesson that stationary frequencies impact how likely we are to see changes in a character. For example, it may be very likely, in a character, to change from 0 to 1. But if the frequency of 0 is very low, we will still seldom see this change.</p>
<p>We can exploit the relationship between state frequencies and observed changes to allow for variable Q matrices across characters (Fig. 2). To do this, we generate a Beta distribution on state frequencies, and use the state frequencies from that Beta distribution to generate a series of Q-matrices to use to evaluate our data <span class="citation">(Pagel and Meade 2004)</span>.</p>
<p>This type of model is called a <strong>mixture model</strong>. There are assumed to be subdivisions in the data, which may require different parameters (in this case, state frequencies). These subdivisions are not defined <em>a priori</em>. This model has previously been shown to be effective for a range of empirical and simulated datasets <span class="citation">(Wright, Lloyd, and Hillis 2016)</span>.</p>
<div id="modifying-the-mcmc-file" class="section level2">
<h2 class="hasAnchor">
<a href="#modifying-the-mcmc-file" class="anchor"></a>Modifying the MCMC File</h2>
<p>At each place in which the output files are specified in the MCMC file, change the output path so you don’t overwrite the output from the previous exercise. For example, you might call your output file <span><span><code>output/mk_discretized.log</code></span></span> and <span><span><code>output/mk_discretized.trees</code></span></span>. Change source statement to indicate the new model file.</p>
</div>
<div id="modifying-the-model-file" class="section level2">
<h2 class="hasAnchor">
<a href="#modifying-the-model-file" class="anchor"></a>Modifying the Model File</h2>
<p>Open the new model file that you created. We need to modify the way in which the Q matrix is specified. We will use a discretized Beta distribution to place a prior on state frequencies. The Beta distribution has two parameters, <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>. These two parameters specify the shape of the distribution. State frequencies will be evaluated according to this distribution, in the same way that rate variation is evaluated according to the Gamma distribution. The discretized distribution is split into multiple classes, each with it’s own set of frequencies for the 0 and 1 characters. The number of classes can vary; we have chosen 4 for tractability.</p>
<pre><code>n_cats = 4
alpha_ofbeta ~ dnExponential( 1 )
beta_ofbeta ~ dnExponential( 1 )
moves[mvi++] = mvScale(alpha_ofbeta, lambda=1,    weight=1.0 )
moves[mvi++] = mvScale(alpha_ofbeta, lambda=0.1,  weight=3.0 )
moves[mvi++] = mvScale(alpha_ofbeta, lambda=0.01, weight=5.0 )
moves[mvi++] = mvScale(beta_ofbeta, lambda=1,    weight=1.0 )
moves[mvi++] = mvScale(beta_ofbeta, lambda=0.1,  weight=3.0 )
moves[mvi++] = mvScale(beta_ofbeta, lambda=0.01, weight=5.0 )</code></pre>
<p>Above, we initialized the number of categories, the parameters to the Beta distribution, and the moves on the parameters to the Beta.</p>
<p>Next, we set the categories to each represent a quadrant of the Beta distribution specified by the <span><span><code>alpha_ofbeta</code></span></span> and <span><span><code>beta_ofbeta</code></span></span>. The <span>+1</span> values are added to the beta shape and scale parameters to prevent model overfitting.</p>
<pre><code>cats := fnDiscretizeBeta(alpha_ofbeta+1, beta_ofbeta+1, 4)</code></pre>
<p>If you were to print the <span><span><code>cats</code></span></span> variable, you would see a list of state frequencies like so:</p>
<p>Using these state frequencies, we will generate a new vector of Q matrices. Because we are varying the state frequencies, we must use a Q matrix generation function that allows for state frequencies to vary as a parameter. We will, therefore, use the <span><span><code>fnF81</code></span></span> function.</p>
<pre><code>for (i in 1:cats.size())
{
    Q[i] := fnF81(simplex(abs(1-cats[i]), cats[i]))
}</code></pre>
<p>Once we’ve made the our vector of matrices, we specified moves on our matrix vector:</p>
<pre><code>matrix_probs ~ dnDirichlet(v(1,1,1,1))
moves[mvi++] = mvSimplexElementScale(matrix_probs, alpha=10, weight=1.0) </code></pre>
<p>This Dirichlet prior says that no category is expected to have more characters than another. If you expected some category to hold more of the characters, you could put more weight on that category.</p>
<p>The only other specification that needs to change in the model file is the CTMC:</p>
<pre><code>phyMorpho ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho, Q=Q, type="Standard", coding="variable", siteMatrices=matrix_probs)</code></pre>
<p>You’ll notice that we’ve added a command to tell the CTMC that we have multiple site matrices that will be applied to different characters in the matrix.</p>
<div id="set-up-the-mcmc-1" class="section level3">
<h3 class="hasAnchor">
<a href="#set-up-the-mcmc-1" class="anchor"></a>Set-Up the MCMC</h3>
<p>The MCMC chain set-up does not need to change. Run the new MCMC file, just as you ran the plain Mk file. This estimation will take longer than the Mk model, due to increased model complexity.</p>
</div>
</div>
</div>
<div id="sec:dm_dir" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:dm_dir" class="anchor"></a>Site-Heterogeneous Discrete Morphology Model</h1>
<div class="figure">
<img src="figures/tikz/catlike.png" alt="SHDM model"><p class="caption">SHDM model</p>
</div>
<p>In the previous example, we explored allowing among-character variation in state frequencies. This is an excellent start for allowing more complex models for morphology. But this approach also has several shortcomings. First, because we use a Beta distribution, this model really only works for binary data. Secondly, oftentimes, we will not have a good idea of the shape of the distribution from which we expect state frequencies to be drawn.</p>
<p>To accommodate for these concerns, <span><code>RevBayes</code></span>also has a model that is similar to the CAT model <span class="citation">(Lartillot and Philippe 2004)</span>.</p>
<p>The site-heterogeneous discrete morphology model (SHDM) uses a hyperprior on the prior on state frequencies to mix over different possible combinations state frequencies. In this mixture model, F81 Q-matrices (an extension of the Jukes-Cantor which allows for different state frequencies between characters) is initialized from a set of state frequencies. The number of Q-matrices initialized is equal to the number of user-defined categories, as in the discretized Beta model. The state frequencies used to initialize the Q-matrices are drawn from a Dirichelet prior distribution, which is generated by drawing values from an exponential hyperprior distribution. This model is visualized in Fig. 3.</p>
<div id="example-site-heterogeneous-discrete-morphology-model" class="section level2">
<h2 class="hasAnchor">
<a href="#example-site-heterogeneous-discrete-morphology-model" class="anchor"></a>Example: Site-Heterogeneous Discrete Morphology Model</h2>
<p>Make a copy of the MCMC and model files you just made. Call them <span><span><code>mcmc_mk_hyperprior.Rev</code></span></span> and <span><span><code>model_mk_hyperprior.Rev</code></span></span>. These will contain the new model parameters and models.</p>
</div>
<div id="modifying-the-mcmc-file-1" class="section level2">
<h2 class="hasAnchor">
<a href="#modifying-the-mcmc-file-1" class="anchor"></a>Modifying the MCMC File</h2>
<p>At each place in which the output files are specified in the MCMC file, change the output path so you don’t overwrite the output from the previous exercise. For example, you might call your output file <span><span><code>output/mk_hyperprior.log</code></span></span> and <span><span><code>output/mk_hyperprior.trees</code></span></span>. We will also monitor Q_morpho and pi. Add Q_morpho and pi to the <span><span><code>mnScreen</code></span></span>. Change source statement to indicate the new model file.</p>
</div>
<div id="modifying-the-model-file-1" class="section level2">
<h2 class="hasAnchor">
<a href="#modifying-the-model-file-1" class="anchor"></a>Modifying the Model File</h2>
<p>Open the new model file that you created. We need to modify the way in which the Q-matrix is specified. First, we will create a hyperprior called <span><span><code>dir_alpha</code></span></span> and specify a move on it.</p>
<pre><code>dir_alpha ~ dnExponential(1)
moves[mvi++] = mvScale(dir_alpha, lambda=1,    weight=1.0 )
moves[mvi++] = mvScale(dir_alpha, lambda=0.1,  weight=3.0 )
moves[mvi++] = mvScale(dir_alpha, lambda=0.01, weight=5.0 )</code></pre>
<p>This hyperparameter, dir_alpha, will be used as a parameter to a Dirichelet distribution from which our state frequencies will be drawn.</p>
<pre><code>pi_prior := v(dir_alpha,dir_alpha)</code></pre>
<p>If you were using multistate data, the dir_alpha can be repeated for each state. Next, we will modify our previous loop to use these state frequencies to initialize our Q-matrices.</p>
<pre><code>for(i in 1:n_cats)
{
    pi[i] ~ dnDirichlet(pi_prior)
    moves[mvi++] = mvSimplexElementScale(pi[i], alpha=10, weight=1.0) 
    
    Q_morpho[i] := fnF81(pi[i])
}</code></pre>
<p>In the above loop, for each of our categories, we make a new draw of state frequencies from our Dirichelet distribution (the shape of which is determined by our dir_alpha values). We then use <span><span><code>fnF81</code></span></span> to make our Q-matrices. For each <span><span><code>RevBayes</code></span></span> iteration, we will have 4 pi values and 4 Q-matrices, one for each of the number of categories we specified.</p>
<p>No other aspects of the model file need to change. Run the MCMC as before.</p>
</div>
</div>
<div id="evaluate-and-summarize-your-results" class="section level1">
<h1 class="hasAnchor">
<a href="#evaluate-and-summarize-your-results" class="anchor"></a>Evaluate and Summarize Your Results</h1>
<div id="evaluate-mcmc" class="section level2">
<h2 class="hasAnchor">
<a href="#evaluate-mcmc" class="anchor"></a>Evaluate MCMC</h2>
<p>We will use <span><code>Tracer</code></span>to evaluate the MCMC samples from our three estimations. Load all three of the MCMC logs into the <span><code>Tracer</code></span>window. The MCMC chains will not have converged because they have not been run very long. Highlight all three files in the upper left-hand viewer (Fig. <span class="math display">\[fig:tracer-files\]</span>) by right- or command-clicking all three files.</p>
<div class="figure">
<img src="figures/tracer_load_file.png" alt="tracer"><p class="caption">tracer</p>
</div>
<p>Once all three trace logs are loaded and highlighted, first look at the estimated marginal likelihoods. You will notice that the Mk model, as originally proposed by <span class="citation">(Lewis 2001)</span> is improved by allowing any state frequency heterogeneity at all. The discretized model and the Dirichlet model both represent improvements, but are fairly close in likelihood score to each other (Fig. <span class="math display">\[fig:tracer-llik\]</span>). Likely, we would need to perform stepping stone model assessment to truly tell if the more complicated model is statistically justified. This analysis is too complicated and time-consuming for this tutorial period, but you will find instructions below for performing the analysis.</p>
<div class="figure">
<img src="figures/trace.png" alt="tracer"><p class="caption">tracer</p>
</div>
<p>Click on the ‘Trace’ panel. In the lower left hand corner, you will notice an option to color each trace by the file it came from. Choose this option (you may need to expand the window slightly to see it). Next to this option, you can also see an option to add a legend to your trace window. The results of this coloring can be seen in Fig. <span class="math display">\[fig:coltrace\]</span>. When the coloring is working, you will see that the Mk model mixes quite well, but that mixing becomes worse as we relax the assumption of equal state frequencies. This is because we are greatly increasing model complexity. Therefore, we would need to run the MCMC chains longer if we were to use these analyses in a paper.</p>
<div class="figure">
<img src="figures/colortrace.png" alt="tracer"><p class="caption">tracer</p>
</div>
<p>We are interested in two aspects of the posterior distribution. First, all analyses correct for the biased sampling of variable characters except for the <span>simple</span> analysis. Then, we expect the <span>tree_length</span> variable to be greater for <span>simple</span> than for the remaining analyses, because our data are enriched for variation. Figure <span class="math display">\[fig:tracer\_tree\_length\]</span> shows that <span>tree_length</span> is approximately 30% greater for <span>simple</span> than for <span>mk_simple</span>, which are identical except that <span>mk_simple</span> corrects for sampling bias. To compare these densities, click the “Marginal Prob Distribution” tab in the upper part of the window, highlight all of the loaded Trace Files, then select <span>tree_length</span> from the list of Traces.</p>
<div class="figure">
<img src="figures/tracer_tree_length.png" alt="tracer"><p class="caption">tracer</p>
</div>
<p>Second, we are interested in characterizing the degree of heterogeneity estimated by the beta-discretized model. If the data were distributed by a single morphological rate matrix, then we would expect to see very little variation among the different values in <span>cats</span>, and very large values for the shape and scale parameters of the discrete-beta distribution. For example, if <span>alpha_ofbeta = beta_ofbeta = 1000</span>, then that would cause all discrete-beta categories to have values approaching 0.5, which approximates a symmetric Mk model.</p>
<div class="figure">
<img src="figures/cats.png" alt="tracer"><p class="caption">tracer</p>
</div>
<div class="figure">
<img src="figures/alpha_beta.png" alt="tracer"><p class="caption">tracer</p>
</div>
<p>Figure 8 shows that the four discrete-beta state frequencies do not all have the exact same value. In addition, Figure 9 shows that the priors on the discrete-beta distribution are small enough that we expect to see variance among <span>cat</span> values. If the data contained no information regarding the distribution of <span>cat</span> values, then the posterior estimates for <span>alpha_ofbeta</span> and <span>beta_ofbeta</span> would resemble the prior.</p>
</div>
<div id="summarizing-tree-estimates" class="section level2">
<h2 class="hasAnchor">
<a href="#summarizing-tree-estimates" class="anchor"></a>Summarizing tree estimates</h2>
<p>The morphology trees estimated under the Mk model and discretized Beta are summarized using a majority rule consensus tree (MRCT). Clades appearing in <span class="math inline">\(p&gt;0.5\)</span> of posterior samples are resolved in the MRCT, while poorly support clades with <span class="math inline">\(p \leq 0.5\)</span> are shown as unresolved polytomies. Poor phylogenetic resolution might be caused by having too few phylogenetically informative characters, or it might be due to conflicting signals for certain species relationships. Because phylogenetic information is generated through model choice, let’s compare our topological estimates across models.</p>
<p>The MRCTs for the simple model with and without the +v correction are very similar to that for the discretized-beta model. Note that the scale bars for branch lengths differ greatly, indicating that tree length estimates are inflated without the +v correction, just as we saw when comparing the posterior tree length densities. In general, it is important to assess whether your results are sensitive to model assumptions, such as the degree of model complexity, and any mechanistic assumptions that motivate the model’s design. In this case, our tree estimate appears to be robust to model complexity.</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-abella2011">
<p>Abella, J, P Montoya, and J Morales. 2011. “Una Nueva Especie de <em>Agriarctos</em> (Ailuropodinae, Ursidae, Carnivora) En La Localidad de Nombrevilla 2 (Zaragoza, España).” <em>Estudios Geológicos</em> 67 (2): 187–91.</p>
</div>
<div id="ref-allman08b">
<p>Allman, E. S., and J. A. Rhodes. 2008. “Identifying Evolutionary Trees and Substitution Parameters for the General Markov Model with Invariable Sites.” <em>Mathematical Biosciences</em> 211: 18–33.</p>
</div>
<div id="ref-freudenstein05">
<p>Freudenstein, John V. 2005. “Characters, States and Homology.” <em>Systematic Biology</em> 54 (6): 965.</p>
</div>
<div id="ref-Hoehna2016b">
<p>Höhna, Sebastian, Michael J. Landis, Tracy A. Heath, Bastien Boussau, Nicolas Lartillot, Brian R. Moore, John P. Huelsenbeck, and Fredrik Ronquist. 2016. “RevBayes: Bayesian Phylogenetic Inference Using Graphical Models and an Interactive Model-Specification Language.” <em>Systematic Biology</em> 65 (4): 726–36. <a href="https://doi.org/10.1093/sysbio/syw021" class="uri">https://doi.org/10.1093/sysbio/syw021</a>.</p>
</div>
<div id="ref-Jukes1969">
<p>Jukes, TH, and CR Cantor. 1969. “Evolution of Protein Molecules.” <em>Mammalian Protein Metabolism</em> 3. New York: 21–132.</p>
</div>
<div id="ref-Lartillot2004">
<p>Lartillot, N., and H. Philippe. 2004. “A Bayesian Mixture Model for Across-Site Heterogeneities in the Amino-Acid Replacement Process.” <em>Molecular Biology and Evolution</em> 21: 1095–1109.</p>
</div>
<div id="ref-Lewis2001">
<p>Lewis, Paul O. 2001. “A Likelihood Approach to Estimating Phylogeny from Discrete Morphological Character Data.” <em>Systematic Biology</em> 50 (6). Oxford University Press: 913–25.</p>
</div>
<div id="ref-Pagel2004">
<p>Pagel, M., and A. Meade. 2004. “A Phylogenetic Mixture Model for Detecting Pattern-Heterogeneity in Gene Sequence or Character-State Data.” <em>Systematic Biology</em> 53 (4). Taylor &amp; Francis: 571–81.</p>
</div>
<div id="ref-Phillips06">
<p>Phillips, Aloysius J. 2006. “Homology Assessment and Molecular Sequence Alignment.” <em>Journal of Biomedical Informatics</em> 39 (1): 18–33.</p>
</div>
<div id="ref-Wright2014">
<p>Wright, April M, and David M Hillis. 2014. “Bayesian Analysis Using a Simple Likelihood Model Outperforms Parsimony for Estimation of Phylogeny from Discrete Morphological Data.” <em>PLoS One</em> 9 (10). Public Library of Science: e109210.</p>
</div>
<div id="ref-Wright2016">
<p>Wright, April M., Graeme T. Lloyd, and David M. Hillis. 2016. “Modeling Character Change Heterogeneity in Phylogenetic Analyses of Morphology Through the Use of Priors.” <em>Systematic Biology</em> 65 (4): 602–11.</p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#introduction">Introduction</a><ul class="nav nav-pills nav-stacked">
<li><a href="#contents">Contents</a></li>
      <li><a href="#recommended-tutorials">Recommended tutorials</a></li>
      </ul>
</li>
      <li>
<a href="#overview-of-discrete-morphology-models">Overview of Discrete Morphology Models</a><ul class="nav nav-pills nav-stacked">
<li><a href="#the-mk-model">The Mk Model</a></li>
      <li><a href="#ascertainment-bias">Ascertainment Bias</a></li>
      </ul>
</li>
      <li>
<a href="#example-inferring-a-phylogeny-of-fossil-bears-using-the-mk-model">Example: Inferring a Phylogeny of Fossil Bears Using the Mk Model</a><ul class="nav nav-pills nav-stacked">
<li><a href="#tutorial-format">Tutorial Format</a></li>
      <li><a href="#getting-started">Getting Started }</a></li>
      <li><a href="#creating-revfiles">Creating <span><code>Rev</code></span>Files</a></li>
      <li><a href="#subsect:Exercise-MkModel">The Mk Model</a></li>
      <li><a href="#complete-master-revfile">Complete Master <span><code>Rev</code></span>File</a></li>
      <li><a href="#execute-the-mcmc-analysis">Execute the MCMC Analysis</a></li>
      </ul>
</li>
      <li><a href="#break-lecture">BREAK: Lecture</a></li>
      <li>
<a href="#example-relaxing-the-assumption-of-equal-transition-probabilities">Example: Relaxing the Assumption of Equal Transition Probabilities</a><ul class="nav nav-pills nav-stacked">
<li><a href="#modifying-the-mcmc-file">Modifying the MCMC File</a></li>
      <li><a href="#modifying-the-model-file">Modifying the Model File</a></li>
      </ul>
</li>
      <li>
<a href="#sec:dm_dir">Site-Heterogeneous Discrete Morphology Model</a><ul class="nav nav-pills nav-stacked">
<li><a href="#example-site-heterogeneous-discrete-morphology-model">Example: Site-Heterogeneous Discrete Morphology Model</a></li>
      <li><a href="#modifying-the-mcmc-file-1">Modifying the MCMC File</a></li>
      <li><a href="#modifying-the-model-file-1">Modifying the Model File</a></li>
      </ul>
</li>
      <li>
<a href="#evaluate-and-summarize-your-results">Evaluate and Summarize Your Results</a><ul class="nav nav-pills nav-stacked">
<li><a href="#evaluate-mcmc">Evaluate MCMC</a></li>
      <li><a href="#summarizing-tree-estimates">Summarizing tree estimates</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by April Wright.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
